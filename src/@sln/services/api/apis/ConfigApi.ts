/* tslint:disable */
/* eslint-disable */
/**
 * Launch Library
 * The Launch Library API is a product by The Space Devs with an up-to-date database of Spaceflight events.   While this API is free to use it is subject to rate limiting for non-authenticated requests.  Please use https://lldev.thespacedevs.com for development testing - the development endpoint has stale data but is not subject to any rate limits.  If you are interested in a higher rate limit please consider supporting the project on Patreon for access to an API Key.
 *
 * The version of the OpenAPI document: v2.2.0
 * Contact: support@thespacedevs.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AgencyType,
    AgencyTypeFromJSON,
    AgencyTypeToJSON,
    AstronautRole,
    AstronautRoleFromJSON,
    AstronautRoleToJSON,
    AstronautStatus,
    AstronautStatusFromJSON,
    AstronautStatusToJSON,
    AstronautType,
    AstronautTypeFromJSON,
    AstronautTypeToJSON,
    DockingLocation,
    DockingLocationFromJSON,
    DockingLocationToJSON,
    EventType,
    EventTypeFromJSON,
    EventTypeToJSON,
    FirstStageType,
    FirstStageTypeFromJSON,
    FirstStageTypeToJSON,
    LandingLocation,
    LandingLocationFromJSON,
    LandingLocationToJSON,
    LaunchStatus,
    LaunchStatusFromJSON,
    LaunchStatusToJSON,
    LauncherConfigDetail,
    LauncherConfigDetailFromJSON,
    LauncherConfigDetailToJSON,
    MissionType,
    MissionTypeFromJSON,
    MissionTypeToJSON,
    NoticeType,
    NoticeTypeFromJSON,
    NoticeTypeToJSON,
    Orbit,
    OrbitFromJSON,
    OrbitToJSON,
    PaginatedAgencyTypeList,
    PaginatedAgencyTypeListFromJSON,
    PaginatedAgencyTypeListToJSON,
    PaginatedAstronautRoleList,
    PaginatedAstronautRoleListFromJSON,
    PaginatedAstronautRoleListToJSON,
    PaginatedAstronautStatusList,
    PaginatedAstronautStatusListFromJSON,
    PaginatedAstronautStatusListToJSON,
    PaginatedAstronautTypeList,
    PaginatedAstronautTypeListFromJSON,
    PaginatedAstronautTypeListToJSON,
    PaginatedDockingLocationList,
    PaginatedDockingLocationListFromJSON,
    PaginatedDockingLocationListToJSON,
    PaginatedEventTypeList,
    PaginatedEventTypeListFromJSON,
    PaginatedEventTypeListToJSON,
    PaginatedFirstStageTypeList,
    PaginatedFirstStageTypeListFromJSON,
    PaginatedFirstStageTypeListToJSON,
    PaginatedLandingLocationList,
    PaginatedLandingLocationListFromJSON,
    PaginatedLandingLocationListToJSON,
    PaginatedLaunchStatusList,
    PaginatedLaunchStatusListFromJSON,
    PaginatedLaunchStatusListToJSON,
    PaginatedLauncherConfigList,
    PaginatedLauncherConfigListFromJSON,
    PaginatedLauncherConfigListToJSON,
    PaginatedMissionTypeList,
    PaginatedMissionTypeListFromJSON,
    PaginatedMissionTypeListToJSON,
    PaginatedNoticeTypeList,
    PaginatedNoticeTypeListFromJSON,
    PaginatedNoticeTypeListToJSON,
    PaginatedOrbitList,
    PaginatedOrbitListFromJSON,
    PaginatedOrbitListToJSON,
    PaginatedRoadClosureStatusList,
    PaginatedRoadClosureStatusListFromJSON,
    PaginatedRoadClosureStatusListToJSON,
    PaginatedSpaceStationStatusList,
    PaginatedSpaceStationStatusListFromJSON,
    PaginatedSpaceStationStatusListToJSON,
    PaginatedSpacecraftConfigurationList,
    PaginatedSpacecraftConfigurationListFromJSON,
    PaginatedSpacecraftConfigurationListToJSON,
    PaginatedSpacecraftStatusList,
    PaginatedSpacecraftStatusListFromJSON,
    PaginatedSpacecraftStatusListToJSON,
    RoadClosureStatus,
    RoadClosureStatusFromJSON,
    RoadClosureStatusToJSON,
    SpaceStationStatus,
    SpaceStationStatusFromJSON,
    SpaceStationStatusToJSON,
    SpacecraftConfigurationDetail,
    SpacecraftConfigurationDetailFromJSON,
    SpacecraftConfigurationDetailToJSON,
    SpacecraftStatus,
    SpacecraftStatusFromJSON,
    SpacecraftStatusToJSON,
} from '../models';

export interface ConfigAgencytypeListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigAgencytypeRetrieveRequest {
    id: number;
}

export interface ConfigAstronautroleListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigAstronautroleRetrieveRequest {
    id: number;
}

export interface ConfigAstronautstatusListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigAstronautstatusRetrieveRequest {
    id: number;
}

export interface ConfigAstronauttypeListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigAstronauttypeRetrieveRequest {
    id: number;
}

export interface ConfigDockinglocationListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigDockinglocationRetrieveRequest {
    id: number;
}

export interface ConfigEventtypeListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigEventtypeRetrieveRequest {
    id: number;
}

export interface ConfigFirststagetypeListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigFirststagetypeRetrieveRequest {
    id: number;
}

export interface ConfigLandinglocationListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigLandinglocationRetrieveRequest {
    id: number;
}

export interface ConfigLauncherListRequest {
    active?: boolean;
    family?: string;
    fullName?: string;
    limit?: number;
    manufacturer?: number;
    name?: string;
    offset?: number;
    ordering?: string;
    program?: Array<number>;
    reusable?: boolean;
    search?: string;
}

export interface ConfigLauncherRetrieveRequest {
    id: number;
}

export interface ConfigLaunchstatusListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigLaunchstatusRetrieveRequest {
    id: number;
}

export interface ConfigMissiontypeListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigMissiontypeRetrieveRequest {
    id: number;
}

export interface ConfigNoticetypeListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigNoticetypeRetrieveRequest {
    id: number;
}

export interface ConfigOrbitListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigOrbitRetrieveRequest {
    id: number;
}

export interface ConfigRoadclosurestatusListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigRoadclosurestatusRetrieveRequest {
    id: number;
}

export interface ConfigSpacecraftListRequest {
    humanRated?: boolean;
    inUse?: boolean;
    limit?: number;
    manufacturer?: number;
    name?: string;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigSpacecraftRetrieveRequest {
    id: number;
}

export interface ConfigSpacecraftstatusListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigSpacecraftstatusRetrieveRequest {
    id: number;
}

export interface ConfigSpacestationstatusListRequest {
    limit?: number;
    offset?: number;
    ordering?: string;
    search?: string;
}

export interface ConfigSpacestationstatusRetrieveRequest {
    id: number;
}

/**
 * 
 */
export class ConfigApi extends runtime.BaseAPI {

    /**
     */
    async configAgencytypeListRaw(requestParameters: ConfigAgencytypeListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedAgencyTypeList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/agencytype/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedAgencyTypeListFromJSON(jsonValue));
    }

    /**
     */
    async configAgencytypeList(requestParameters: ConfigAgencytypeListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedAgencyTypeList> {
        const response = await this.configAgencytypeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configAgencytypeRetrieveRaw(requestParameters: ConfigAgencytypeRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AgencyType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configAgencytypeRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/agencytype/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AgencyTypeFromJSON(jsonValue));
    }

    /**
     */
    async configAgencytypeRetrieve(requestParameters: ConfigAgencytypeRetrieveRequest, initOverrides?: RequestInit): Promise<AgencyType> {
        const response = await this.configAgencytypeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configAstronautroleListRaw(requestParameters: ConfigAstronautroleListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedAstronautRoleList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/astronautrole/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedAstronautRoleListFromJSON(jsonValue));
    }

    /**
     */
    async configAstronautroleList(requestParameters: ConfigAstronautroleListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedAstronautRoleList> {
        const response = await this.configAstronautroleListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configAstronautroleRetrieveRaw(requestParameters: ConfigAstronautroleRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AstronautRole>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configAstronautroleRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/astronautrole/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AstronautRoleFromJSON(jsonValue));
    }

    /**
     */
    async configAstronautroleRetrieve(requestParameters: ConfigAstronautroleRetrieveRequest, initOverrides?: RequestInit): Promise<AstronautRole> {
        const response = await this.configAstronautroleRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configAstronautstatusListRaw(requestParameters: ConfigAstronautstatusListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedAstronautStatusList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/astronautstatus/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedAstronautStatusListFromJSON(jsonValue));
    }

    /**
     */
    async configAstronautstatusList(requestParameters: ConfigAstronautstatusListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedAstronautStatusList> {
        const response = await this.configAstronautstatusListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configAstronautstatusRetrieveRaw(requestParameters: ConfigAstronautstatusRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AstronautStatus>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configAstronautstatusRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/astronautstatus/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AstronautStatusFromJSON(jsonValue));
    }

    /**
     */
    async configAstronautstatusRetrieve(requestParameters: ConfigAstronautstatusRetrieveRequest, initOverrides?: RequestInit): Promise<AstronautStatus> {
        const response = await this.configAstronautstatusRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configAstronauttypeListRaw(requestParameters: ConfigAstronauttypeListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedAstronautTypeList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/astronauttype/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedAstronautTypeListFromJSON(jsonValue));
    }

    /**
     */
    async configAstronauttypeList(requestParameters: ConfigAstronauttypeListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedAstronautTypeList> {
        const response = await this.configAstronauttypeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configAstronauttypeRetrieveRaw(requestParameters: ConfigAstronauttypeRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AstronautType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configAstronauttypeRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/astronauttype/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AstronautTypeFromJSON(jsonValue));
    }

    /**
     */
    async configAstronauttypeRetrieve(requestParameters: ConfigAstronauttypeRetrieveRequest, initOverrides?: RequestInit): Promise<AstronautType> {
        const response = await this.configAstronauttypeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configDockinglocationListRaw(requestParameters: ConfigDockinglocationListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedDockingLocationList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/dockinglocation/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedDockingLocationListFromJSON(jsonValue));
    }

    /**
     */
    async configDockinglocationList(requestParameters: ConfigDockinglocationListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedDockingLocationList> {
        const response = await this.configDockinglocationListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configDockinglocationRetrieveRaw(requestParameters: ConfigDockinglocationRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<DockingLocation>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configDockinglocationRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/dockinglocation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DockingLocationFromJSON(jsonValue));
    }

    /**
     */
    async configDockinglocationRetrieve(requestParameters: ConfigDockinglocationRetrieveRequest, initOverrides?: RequestInit): Promise<DockingLocation> {
        const response = await this.configDockinglocationRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configEventtypeListRaw(requestParameters: ConfigEventtypeListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedEventTypeList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/eventtype/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedEventTypeListFromJSON(jsonValue));
    }

    /**
     */
    async configEventtypeList(requestParameters: ConfigEventtypeListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedEventTypeList> {
        const response = await this.configEventtypeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configEventtypeRetrieveRaw(requestParameters: ConfigEventtypeRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<EventType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configEventtypeRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/eventtype/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EventTypeFromJSON(jsonValue));
    }

    /**
     */
    async configEventtypeRetrieve(requestParameters: ConfigEventtypeRetrieveRequest, initOverrides?: RequestInit): Promise<EventType> {
        const response = await this.configEventtypeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configFirststagetypeListRaw(requestParameters: ConfigFirststagetypeListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedFirstStageTypeList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/firststagetype/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedFirstStageTypeListFromJSON(jsonValue));
    }

    /**
     */
    async configFirststagetypeList(requestParameters: ConfigFirststagetypeListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedFirstStageTypeList> {
        const response = await this.configFirststagetypeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configFirststagetypeRetrieveRaw(requestParameters: ConfigFirststagetypeRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FirstStageType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configFirststagetypeRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/firststagetype/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FirstStageTypeFromJSON(jsonValue));
    }

    /**
     */
    async configFirststagetypeRetrieve(requestParameters: ConfigFirststagetypeRetrieveRequest, initOverrides?: RequestInit): Promise<FirstStageType> {
        const response = await this.configFirststagetypeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configLandinglocationListRaw(requestParameters: ConfigLandinglocationListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedLandingLocationList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/landinglocation/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedLandingLocationListFromJSON(jsonValue));
    }

    /**
     */
    async configLandinglocationList(requestParameters: ConfigLandinglocationListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedLandingLocationList> {
        const response = await this.configLandinglocationListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configLandinglocationRetrieveRaw(requestParameters: ConfigLandinglocationRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LandingLocation>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configLandinglocationRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/landinglocation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LandingLocationFromJSON(jsonValue));
    }

    /**
     */
    async configLandinglocationRetrieve(requestParameters: ConfigLandinglocationRetrieveRequest, initOverrides?: RequestInit): Promise<LandingLocation> {
        const response = await this.configLandinglocationRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * API endpoint that allows Launcher Configurations to be viewed.  GET: Return a list of all the existing launcher configurations.  MODE: Normal and Detailed /2.2.0/config/launcher/?mode=detailed  FILTERS: Fields - \'family\', \'agency\', \'name\', \'manufacturer__name\', \'full_name\'  Get all Launchers with the Agency with name NASA. Example - /2.2.0/config/launcher/?manufacturer__name=NASA
     */
    async configLauncherListRaw(requestParameters: ConfigLauncherListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedLauncherConfigList>> {
        const queryParameters: any = {};

        if (requestParameters.active !== undefined) {
            queryParameters['active'] = requestParameters.active;
        }

        if (requestParameters.family !== undefined) {
            queryParameters['family'] = requestParameters.family;
        }

        if (requestParameters.fullName !== undefined) {
            queryParameters['full_name'] = requestParameters.fullName;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.manufacturer !== undefined) {
            queryParameters['manufacturer'] = requestParameters.manufacturer;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.program) {
            queryParameters['program'] = requestParameters.program;
        }

        if (requestParameters.reusable !== undefined) {
            queryParameters['reusable'] = requestParameters.reusable;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/launcher/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedLauncherConfigListFromJSON(jsonValue));
    }

    /**
     * API endpoint that allows Launcher Configurations to be viewed.  GET: Return a list of all the existing launcher configurations.  MODE: Normal and Detailed /2.2.0/config/launcher/?mode=detailed  FILTERS: Fields - \'family\', \'agency\', \'name\', \'manufacturer__name\', \'full_name\'  Get all Launchers with the Agency with name NASA. Example - /2.2.0/config/launcher/?manufacturer__name=NASA
     */
    async configLauncherList(requestParameters: ConfigLauncherListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedLauncherConfigList> {
        const response = await this.configLauncherListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * API endpoint that allows Launcher Configurations to be viewed.  GET: Return a list of all the existing launcher configurations.  MODE: Normal and Detailed /2.2.0/config/launcher/?mode=detailed  FILTERS: Fields - \'family\', \'agency\', \'name\', \'manufacturer__name\', \'full_name\'  Get all Launchers with the Agency with name NASA. Example - /2.2.0/config/launcher/?manufacturer__name=NASA
     */
    async configLauncherRetrieveRaw(requestParameters: ConfigLauncherRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LauncherConfigDetail>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configLauncherRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/launcher/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LauncherConfigDetailFromJSON(jsonValue));
    }

    /**
     * API endpoint that allows Launcher Configurations to be viewed.  GET: Return a list of all the existing launcher configurations.  MODE: Normal and Detailed /2.2.0/config/launcher/?mode=detailed  FILTERS: Fields - \'family\', \'agency\', \'name\', \'manufacturer__name\', \'full_name\'  Get all Launchers with the Agency with name NASA. Example - /2.2.0/config/launcher/?manufacturer__name=NASA
     */
    async configLauncherRetrieve(requestParameters: ConfigLauncherRetrieveRequest, initOverrides?: RequestInit): Promise<LauncherConfigDetail> {
        const response = await this.configLauncherRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configLaunchstatusListRaw(requestParameters: ConfigLaunchstatusListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedLaunchStatusList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/launchstatus/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedLaunchStatusListFromJSON(jsonValue));
    }

    /**
     */
    async configLaunchstatusList(requestParameters: ConfigLaunchstatusListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedLaunchStatusList> {
        const response = await this.configLaunchstatusListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configLaunchstatusRetrieveRaw(requestParameters: ConfigLaunchstatusRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LaunchStatus>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configLaunchstatusRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/launchstatus/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LaunchStatusFromJSON(jsonValue));
    }

    /**
     */
    async configLaunchstatusRetrieve(requestParameters: ConfigLaunchstatusRetrieveRequest, initOverrides?: RequestInit): Promise<LaunchStatus> {
        const response = await this.configLaunchstatusRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configMissiontypeListRaw(requestParameters: ConfigMissiontypeListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedMissionTypeList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/missiontype/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedMissionTypeListFromJSON(jsonValue));
    }

    /**
     */
    async configMissiontypeList(requestParameters: ConfigMissiontypeListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedMissionTypeList> {
        const response = await this.configMissiontypeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configMissiontypeRetrieveRaw(requestParameters: ConfigMissiontypeRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<MissionType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configMissiontypeRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/missiontype/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MissionTypeFromJSON(jsonValue));
    }

    /**
     */
    async configMissiontypeRetrieve(requestParameters: ConfigMissiontypeRetrieveRequest, initOverrides?: RequestInit): Promise<MissionType> {
        const response = await this.configMissiontypeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configNoticetypeListRaw(requestParameters: ConfigNoticetypeListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedNoticeTypeList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/noticetype/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedNoticeTypeListFromJSON(jsonValue));
    }

    /**
     */
    async configNoticetypeList(requestParameters: ConfigNoticetypeListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedNoticeTypeList> {
        const response = await this.configNoticetypeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configNoticetypeRetrieveRaw(requestParameters: ConfigNoticetypeRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<NoticeType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configNoticetypeRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/noticetype/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NoticeTypeFromJSON(jsonValue));
    }

    /**
     */
    async configNoticetypeRetrieve(requestParameters: ConfigNoticetypeRetrieveRequest, initOverrides?: RequestInit): Promise<NoticeType> {
        const response = await this.configNoticetypeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configOrbitListRaw(requestParameters: ConfigOrbitListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedOrbitList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/orbit/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedOrbitListFromJSON(jsonValue));
    }

    /**
     */
    async configOrbitList(requestParameters: ConfigOrbitListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedOrbitList> {
        const response = await this.configOrbitListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configOrbitRetrieveRaw(requestParameters: ConfigOrbitRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Orbit>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configOrbitRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/orbit/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrbitFromJSON(jsonValue));
    }

    /**
     */
    async configOrbitRetrieve(requestParameters: ConfigOrbitRetrieveRequest, initOverrides?: RequestInit): Promise<Orbit> {
        const response = await this.configOrbitRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configRoadclosurestatusListRaw(requestParameters: ConfigRoadclosurestatusListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedRoadClosureStatusList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/roadclosurestatus/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedRoadClosureStatusListFromJSON(jsonValue));
    }

    /**
     */
    async configRoadclosurestatusList(requestParameters: ConfigRoadclosurestatusListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedRoadClosureStatusList> {
        const response = await this.configRoadclosurestatusListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configRoadclosurestatusRetrieveRaw(requestParameters: ConfigRoadclosurestatusRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RoadClosureStatus>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configRoadclosurestatusRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/roadclosurestatus/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoadClosureStatusFromJSON(jsonValue));
    }

    /**
     */
    async configRoadclosurestatusRetrieve(requestParameters: ConfigRoadclosurestatusRetrieveRequest, initOverrides?: RequestInit): Promise<RoadClosureStatus> {
        const response = await this.configRoadclosurestatusRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * API endpoint that allows Spacecraft Configs to be viewed.  GET: Return a list of all the existing spacecraft.  FILTERS: Parameters - \'name\', \'manufacturer\', \'in_use\', \'human_rated\' Example - /2.2.0/config/spacecraft/?status=Active  SEARCH EXAMPLE: Example - /2.2.0/config/spacecraft/?search=Dragon  ORDERING: Fields - \'name\' Example - /2.2.0/config/spacecraft/?order=name
     */
    async configSpacecraftListRaw(requestParameters: ConfigSpacecraftListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedSpacecraftConfigurationList>> {
        const queryParameters: any = {};

        if (requestParameters.humanRated !== undefined) {
            queryParameters['human_rated'] = requestParameters.humanRated;
        }

        if (requestParameters.inUse !== undefined) {
            queryParameters['in_use'] = requestParameters.inUse;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.manufacturer !== undefined) {
            queryParameters['manufacturer'] = requestParameters.manufacturer;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/spacecraft/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSpacecraftConfigurationListFromJSON(jsonValue));
    }

    /**
     * API endpoint that allows Spacecraft Configs to be viewed.  GET: Return a list of all the existing spacecraft.  FILTERS: Parameters - \'name\', \'manufacturer\', \'in_use\', \'human_rated\' Example - /2.2.0/config/spacecraft/?status=Active  SEARCH EXAMPLE: Example - /2.2.0/config/spacecraft/?search=Dragon  ORDERING: Fields - \'name\' Example - /2.2.0/config/spacecraft/?order=name
     */
    async configSpacecraftList(requestParameters: ConfigSpacecraftListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedSpacecraftConfigurationList> {
        const response = await this.configSpacecraftListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * API endpoint that allows Spacecraft Configs to be viewed.  GET: Return a list of all the existing spacecraft.  FILTERS: Parameters - \'name\', \'manufacturer\', \'in_use\', \'human_rated\' Example - /2.2.0/config/spacecraft/?status=Active  SEARCH EXAMPLE: Example - /2.2.0/config/spacecraft/?search=Dragon  ORDERING: Fields - \'name\' Example - /2.2.0/config/spacecraft/?order=name
     */
    async configSpacecraftRetrieveRaw(requestParameters: ConfigSpacecraftRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SpacecraftConfigurationDetail>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configSpacecraftRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/spacecraft/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SpacecraftConfigurationDetailFromJSON(jsonValue));
    }

    /**
     * API endpoint that allows Spacecraft Configs to be viewed.  GET: Return a list of all the existing spacecraft.  FILTERS: Parameters - \'name\', \'manufacturer\', \'in_use\', \'human_rated\' Example - /2.2.0/config/spacecraft/?status=Active  SEARCH EXAMPLE: Example - /2.2.0/config/spacecraft/?search=Dragon  ORDERING: Fields - \'name\' Example - /2.2.0/config/spacecraft/?order=name
     */
    async configSpacecraftRetrieve(requestParameters: ConfigSpacecraftRetrieveRequest, initOverrides?: RequestInit): Promise<SpacecraftConfigurationDetail> {
        const response = await this.configSpacecraftRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configSpacecraftstatusListRaw(requestParameters: ConfigSpacecraftstatusListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedSpacecraftStatusList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/spacecraftstatus/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSpacecraftStatusListFromJSON(jsonValue));
    }

    /**
     */
    async configSpacecraftstatusList(requestParameters: ConfigSpacecraftstatusListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedSpacecraftStatusList> {
        const response = await this.configSpacecraftstatusListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configSpacecraftstatusRetrieveRaw(requestParameters: ConfigSpacecraftstatusRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SpacecraftStatus>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configSpacecraftstatusRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/spacecraftstatus/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SpacecraftStatusFromJSON(jsonValue));
    }

    /**
     */
    async configSpacecraftstatusRetrieve(requestParameters: ConfigSpacecraftstatusRetrieveRequest, initOverrides?: RequestInit): Promise<SpacecraftStatus> {
        const response = await this.configSpacecraftstatusRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configSpacestationstatusListRaw(requestParameters: ConfigSpacestationstatusListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaginatedSpaceStationStatusList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/spacestationstatus/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSpaceStationStatusListFromJSON(jsonValue));
    }

    /**
     */
    async configSpacestationstatusList(requestParameters: ConfigSpacestationstatusListRequest = {}, initOverrides?: RequestInit): Promise<PaginatedSpaceStationStatusList> {
        const response = await this.configSpacestationstatusListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async configSpacestationstatusRetrieveRaw(requestParameters: ConfigSpacestationstatusRetrieveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SpaceStationStatus>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling configSpacestationstatusRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // tokenAuth authentication
        }

        const response = await this.request({
            path: `/2.2.0/config/spacestationstatus/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SpaceStationStatusFromJSON(jsonValue));
    }

    /**
     */
    async configSpacestationstatusRetrieve(requestParameters: ConfigSpacestationstatusRetrieveRequest, initOverrides?: RequestInit): Promise<SpaceStationStatus> {
        const response = await this.configSpacestationstatusRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
